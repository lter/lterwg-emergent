# ============================================================================
# microTrait_DataAnalysis.R
# Dawson Fairbanks, PhD
# Oct 29, 2023
# Script for analyzing microTrait functional matrices from 49 bins extracted by metaBat2
# ============================================================================
## Purpose
# This R script is designed to generate and analyze functional matrices using microTrait from bins generated through metagenomic processing.

## Usage
# To run this script, execute it in an interactive R session on the High-Performance Computing (HPC) cluster.

## Input
# The script requires input data in the format of functional matrices generated by microTrait.

## Output
# The script will produce some exploratory PCA plots and dotplots to visualize trait attributes.

## Dependencies and Requirements
# - R version 4.3.1 (2023-06-16) 
# - The microTrait pipeline (available at https://github.com/ukaraoz/microtrait) - includes some heatmaps and other visualization tools for analyzing large bin datasets
# - Download databases and dependencies, including prodigal and HMMs, and set them to your PATH variable in terminal. Databases can be downloaded as part of the R workflow.

## Additional Notes
# - To install microTrait, please be aware that GitHub has rate limits on how much you can download via API. If you encounter issues, use auth_token = "" and generate a token from your GitHub profile to circumvent this problem.

# ============================================================================

# Install Packages

install.packages("devtools")
library(devtools)
list_of_packages = c("R.utils", "RColorBrewer", "ape", "assertthat", "checkmate",
                     "coRdon", "corrplot", "doParallel", "dplyr", "futile.logger", "grid", "gtools", "kmed", "lazyeval", "magrittr", "parallel", "pheatmap", "readr", "stringr", "tibble", 
                     "tictoc", "tidyr")
newpackages <- list_of_packages[!(list_of_packages %in% installed.packages()[,"Package"])]
if(length(newpackages)) install.packages(newpackages)

if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

BiocManager::install("coRdon")
BiocManager::install("Biostrings")
BiocManager::install("coRdon")
BiocManager::install("ComplexHeatmap")

# Developmental package dependencies
devtools::install_github("jlw-ecoevo/gRodon")

# Install microtrait with devtools
devtools::install_github("ukaraoz/microtrait", auth_token = "(insert github token here)") #use auth_token to circumvent rate limit

# load microtrait 
library(microtrait)

# set path to hmmer in R; this was necessary on local machine (didn't take too long running in parallel depending on how big your data is..)
# Sys.setenv(PATH = paste("/Users/dawsonfairbanks/Documents/Bioinformatic_Tools/hmmer-3.4/src", Sys.getenv("PATH"), sep = ":"))
# can also set to PATH variable in bash using `nano ~/.bashrc` and adding export PATH="/opt/linux/rocky/8.x/x86_64/pkgs/prodigal/2.6.3/prodigal:$PATH" and export PATH="opt/linux/rocky/8.x/x86_64/pkgs/hmmer/3.3.2/bin:$PATH" on UCR HPC system

# this should be run once after installation
#microtrait::prep.hmmmodels()
list.files(file.path(.libPaths(), "microtrait/extdata/hmm/hmmpress")) # check that databases downloaded

# extracting traits from genomes:
setwd("/bigdata/aronsonlab/shared/CZNet/Metagenome_Sequences/04_Assembly/02_Megahit_Assembly/02_Contig_Assembly_Megahit/BWA_Map_to_Contigs/Medium_High_Quality_Metabat2_Bins") # change to bin directory

# this is for a single genome file.. not necessary..
# genome_file <- system.file("/rhome/dawsonf/shared/CZNet/Metagenome_Sequences/04_Assembly/02_Megahit_Assembly/02_Contig_Assembly_Megahit/# # BWA_Map_to_Contigs/Medium_High_Quality_Metabat2_Bins/CA_MC_R1_0_6_S3_bin.16.fa", package="microtrait")
# result = extract.traits(genome_file) # this is for a single genome file..

# determine number of cores on computer 
message("Number of cores:", parallel::detectCores(), "\n") # 22

# set genome files 
genome_dir <- "/rhome/dawsonf/shared/CZNet/Metagenome_Sequences/04_Assembly/02_Megahit_Assembly/02_Contig_Assembly_Megahit/BWA_Map_to_Contigs/Medium_High_Quality_Metabat2_Bins"
genomes_files = list.files(genome_dir, full.names = T, recursive = T, pattern = ".fa$")

# using 70% of available cores, note: I ran this on the interactive node just because it didn't take very long to run on my computer on another data set. ¯\_(ツ)_/¯
library("tictoc")
tictoc::tic.clearlog()
tictoc::tic(paste0("Running microtrait for ", length(genomes_files)))
microtrait_results = extract.traits.parallel(genomes_files, dirname(genomes_files), ncores = floor(parallel::detectCores()*0.7))
tictoc::toc(log = "TRUE")

rds_files = unlist(parallel::mclapply(microtrait_results, "[[", "rds_file", mc.cores = 6))

#rds_files <- list.files(pattern = "\\.rds$") # use this if you move the .rds files to a new directory

# build trait matrices
genomeset_results = make.genomeset.results(rds_files = rds_files,
                                           ids = sub(".microtrait.rds", "", basename(rds_files)),
                                           ncores = 1)

# check names
names(genomeset_results)
lapply(genomeset_results, dim)

x <- genomeset_results$trait_matrixatgranularity1
x2 <- genomeset_results$trait_matrixatgranularity2
x3 <- genomeset_results$trait_matrixatgranularity3
hmmdf <- genomeset_results$hmm_matrix
rule_matrix <- genomeset_results$rule_matrix


# write out csvs
write.csv(x, file="microtrait_matrix_gran1.csv")
write.csv(x2, file="micrtrait_matrix_gran2.csv")
write.csv(x3, file="microtrait_matrix_gran3.csv")
write.csv(hmmdf, file="microtrait_matrix_hmmdf.csv")
write.csv(rule_matrix, file="rule_matrix.csv")


# now going to add metadata to original genome_data, contains "Genome_Size" for normalization
# load in data
genome_metadata = readRDS(file.path(base_dir, paste0(dataset, ".metadata.rds")))
genomeset_results_wmetadata = microtrait::add.metadata(genomeset_results, genome_metadata, genome_metadata_idcol = "IMG Taxon ID") %>% convert_traitdatatype(binarytype = "logical")

# check names
names(genomeset_results)
lapply(genomeset_results, dim)

x <- genomeset_results$trait_matrixatgranularity1
x2 <- genomeset_results$trait_matrixatgranularity2
x3 <- genomeset_results$trait_matrixatgranularity3
hmmdf <- genomeset_results$hmm_matrix

write.csv(x, file="/Users/dawsonfairbanks/Documents/CZNET_CSP_MetaG/trait_matrix_gran1.csv")
write.csv(x2, file="/Users/dawsonfairbanks/Documents/CZNET_CSP_MetaG/trait_matrix_gran2.csv")
write.csv(x3, file="/Users/dawsonfairbanks/Documents/CZNET_CSP_MetaG/trait_matrix_gran3.csv")
write.csv(hmmdf, file="/Users/dawsonfairbanks/Documents/CZNET_CSP_MetaG/dawson_hmmdf.csv")


# =============================================================================================
# from here you can use the trait matrices produced and generate figures in RStudio
# =============================================================================================
# import metadata
setwd("/Users/dawsonfairbanks/Documents/CZNET_CSP_MetaG/Data_Analysis/microTrait_Analysis/05_Processed_Data/")

setwd("Documents/CZNET_GeoMicro_MetaG/Data_Analysis/Microtrait/02_Processed_Data")
meta_data<-readr::read_csv("/Users/dawsonfairbanks/Documents/CZNET_CSP_MetaG/Data_Analysis/microTrait_Analysis/05_Processed_Data/microtrait_csp_meta_data.csv")
meta_data$id
genomeset_results$trait_matrixatgranularity3$id

# Match row order from df1 to df2
match_order <- match(genomeset_results$trait_matrixatgranularity3$id, meta_data$id)

# Reorder df2 based on the matched order
meta_data_reordered <- meta_data[match_order, ]

# now add metadata
genomeset_results_wmetadata = microtrait::add.metadata(genomeset_results, meta_data_reordered, genome_metadata_idcol = "id") %>% convert_traitdatatype(binarytype = "logical")
genomeset_results_wmetadata$trait_matrixatgranularity3
genomeset_results_wmetadata_norm = genomeset_results_wmetadata %>% trait.normalize(normby = "Genome_Size")
genomeset_results_wmetadata_norm$trait_matrixatgranularity3

nrow(genomeset_results_wmetadata$trait_matrixatgranularity3)

trait_df <-genomeset_results_wmetadata$trait_matrixatgranularity3

trait_matrix <-trait_df[,-1]
trait_matrix<-trait_matrix[,1:189]
names(trait_matrix)

# Convert values above 0 to 1
trait_matrix[trait_matrix > 0] <- 1

# Convert TRUE to 1 and FALSE to 0
trait_matrix[trait_matrix == TRUE] <- 1
trait_matrix[trait_matrix == FALSE] <- 0

# Print the modified data frame
print(trait_matrix)
nrow(trait_matrix)

# Calculate variance for each variable
variances <- apply(trait_matrix, 2, var)

# Filter out variables with zero variance
non_zero_variance <- variances > 0
trait_matrix_filtered <- trait_matrix[, non_zero_variance]
dim(trait_matrix_filtered)
str(trait_matrix_filtered)

# Convert TRUE to 1 and FALSE to 0
trait_matrix_filtered[trait_matrix_filtered == TRUE] <- 1
trait_matrix_filtered[trait_matrix_filtered == FALSE] <- 0

# Run PCA on the filtered trait matrix
pca_result <- prcomp(trait_matrix_filtered, center = TRUE, scale = TRUE)

# Print a summary of the PCA result
summary(pca_result)

# Create a scree plot to visualize the variance explained by each principal component
screeplot(pca_result)

# Biplot of the first two principal components (PC1 and PC2)
biplot(pca_result)

pc1_scores <- pca_result$x[, 1]  # PC1 scores
pc2_scores <- pca_result$x[, 2]  # PC2 scores

# Create a data frame for the PC1 and PC2 scores
pca_data <- data.frame(PC1 = pc1_scores, PC2 = pc2_scores, Site = meta_data$Site)


# Create the scatter plot with color-coded points
ggplot(pca_data, aes(PC1, PC2, color = factor(Site), fill = factor(Date))) +
  geom_point(size = 5, alpha = 0.8, shape = 21) +
  labs(title = "PCA Functional Diversity by Month", x = "PC1", y = "PC2") +
  scale_fill_manual(values = colours[1:3]) +  # Set fill color manually
  scale_color_manual(values = colours[1:3]) +  # Set color manually
  guides(fill = guide_legend(title = "Site")) +  # Custom legend title
  theme_minimal() +
  theme_bw()


# creating bubble plot
library(reshape)
melt_df<-melt(trait_df_filtered, id="Sample_ID")
melt_df$Sample_ID <- factor(melt_df$Sample_ID,levels=unique(melt_df$Sample_ID))


head(trait_df_filtered)
# Set a seed for reproducibility (optional)
set.seed(123)

# Generate a list of 121 random hex colors
colours <- sample(paste0("#", sprintf("%06X", sample(0:(256^3 - 1), 121, replace = TRUE))), 121)

# View the first few colors
head(colours)
colours

head(melt_df)

# Create bubble plot for binary data
xx = ggplot(melt_df, aes(x = Sample_ID, y = variable)) + 
  geom_point(aes(size = ifelse(value == 1, 6, NA), fill = variable), alpha = 0.75, shape = 21) + 
  labs(x = "", y = "", size = "Relative Abundance (%)", fill = "") + 
  theme(legend.key = element_blank(), 
        axis.text.x = element_text(colour = "black", size = 12, face = "bold", angle = 90, vjust = 0.3, hjust = 1), 
        axis.text.y = element_text(colour = "black", face = "bold", size = 11), 
        legend.text = element_text(size = 10, face = "bold", colour = "black"), 
        legend.title = element_text(size = 12, face = "bold"), 
        panel.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1.2), 
        legend.position = "right") +  
  scale_fill_manual(values = colours, guide = FALSE) + 
  scale_size_identity() +  # Use size identity to avoid scaling bubbles
  scale_y_discrete(limits = rev(levels(melt_df$variable)))

xx

library(patchwork)

gg / xx


barplot<-barplot(trait_df_norm2$optimumT, names.arg = trait_df_norm$id, xlab = "Sample ID", ylab = "Optimum Temperature", col = "blue", main = "Optimum Temperature by Sample")

trait_df_norm2$optimumT
gg <- ggplot(data = trait_df_norm2, aes(x = id, y = optimumT)) +
  geom_bar(stat = "identity", fill = "#C20BA9") +
  labs(x = "Sample ID", y = "Optimum Temperature") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ylim(0, max(trait_df_norm2$optimumT) + 5) 

layout <- gg / xx

# Set the relative heights
heights <- c(1, 20)

# Adjust the plot heights
layout <- layout + plot_layout(heights = heights)

# Print the dotlot with stacked optT barplot
print(layout)

trait_df_norm2$growthrate
gr <- ggplot(data = trait_df_norm2, aes(x = id, y = growthrate)) +
  geom_bar(stat = "identity", fill = "#DCB562") +
  labs(y = "Growth Rate") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ra <- ggplot(data = meta_data, aes(x = Sample_ID, y = MAG_Relative_Abundance)) +
  geom_bar(stat = "identity", fill = "#C20BA9") +
  labs(x = "Sample ID", y = "MAG Relative Abundance (%)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

layout <- gg/ gr / xx

# Set the relative heights
heights <- c(1,1, 20)

# Adjust the plot heights
layout <- layout + plot_layout(heights = heights)

# Print the layout with both stacked bar plots
print(layout)

# calculate percent occurrence
# Define a vector of column names to exclude (last 14 columns)
columns_to_exclude <- tail(names(trait_df_norm2), 15)

# Calculate the percent occurrence for each trait within its column
percent_occurrence <- trait_df_norm2 %>%
  select(-one_of(columns_to_exclude)) %>%  # Exclude the last 14 columns
  summarise(across(everything(), ~ mean(. > 0) * 100, .names = "percent_{.col}"))

colnames(percent_occurrence)

# Add the results as a new vector corresponding to Sample_ID
percent_occurrence_transformed <- percent_occurrence %>%
  pivot_longer(cols = everything(), names_to = "id", values_to = "percentage")

# View the transformed data
head(percent_occurrence_transformed)
percent_occurrence_filtered <- percent_occurrence_transformed %>%
  filter(percentage != 0)

# Remove the first row
percent_occurrence_filtered <- percent_occurrence_filtered[-1, ]
percent_occurrence_filtered <- percent_occurrence_filtered[-1, ]

# View the resulting data frame
head(percent_occurrence_filtered)

percent_occurrence_filtered$id
# Assuming "id" is a factor variable, you can reorder its levels:

percent_occurrence_filtered <- percent_occurrence_filtered[order(factor(percent_occurrence_filtered$id, levels = unique(percent_occurrence_filtered$id))), ]
tail(percent_occurrence_filtered)

# Create a new factor variable for ordering
percent_occurrence_filtered <- percent_occurrence_filtered %>%
  mutate(id = factor(id, levels = unique(id)))

# Reverse the order of rows
percent_occurrence_filtered <- percent_occurrence_filtered %>%
  mutate(id = factor(id, levels = rev(unique(id))))  # Reverse the order of factor levels

po <- ggplot(data = percent_occurrence_filtered, aes(x = id, y = percentage)) +
  geom_bar(stat = "identity", fill = "#DCB562") +
  labs(y = "Percent Occurrence") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  coord_flip()
po

# Set the relative heights
layout <- xx |po
widths <- c(2, 1)

# Adjust the plot heights
layout <- layout + plot_layout(widths = widths)

# Print the layout
print(layout)

# Arrange gg and gr plots as a column
barplots_column <- gg / gr
traits <- xx | po
barplots_column/traits

# Arrange barplots_column and xx plots as a row
row_layout <- barplots_column / xx

# Create the final layout with po to the right of the row layout
final_layout <- row_layout | po
final_layout 

# I combined these plots in illustrator :)


# ========================================================
# bonus dotplot that includes sizing by relative abundance on a phyloseq object
# Bacterial Dotplot Relative Abundance
# =============================================================
# add ASVs with best taxonomy
rank_names(mergedf) # this is my phyloseq ojbect with sample_data, otu_table, and meta_data

# changing to domain
tax_table <- tax_table(mergedf)
colnames(tax_table)
colnames(tax_table)[colnames(tax_table) == "Kingdom"] <- "Domain"
tax_table(mergedf) <- tax_table
colnames(tax_table)

# adding tax table to ASV
merge_best <- microbiome::add_besthit(mergedf)
taxa_names(merge_best)[1:2]

# Aggregate taxa at the phylum level
GP.phylum <- tax_glom(merge_best, taxrank = "Phylum")

# Top N taxa
N <- 20
top <- names(sort(taxa_sums(GP.phylum), decreasing = TRUE))[1:N]

# Calculate relative abundance
GP.phylum.prop <- transform_sample_counts(GP.phylum, function(x) x / sum(x))

# Subset object to top N taxa
GP.phylum.prop.top <- prune_taxa(top, GP.phylum.prop)

# Create long format
melt_phyloseq <- phyloseq::psmelt(GP.phylum.prop.top)

str(melt_phyloseq)
head(melt_phyloseq$Abundance)

dotplot_bacteria = ggplot(melt_phyloseq, aes(x = Sample, y = Phylum)) + 
  geom_point(aes(size = Abundance, fill = Phylum), alpha = 0.75, shape = 21) + 
  scale_size_continuous(limits = c(0.000001, 50), range = c(0, 50), breaks = c(0, .10, .50, .75)) + 
  labs(x = "", y = "", fill = "Phylum") + 
  theme(legend.key = element_blank(), 
        axis.text.x = element_text(colour = "black", size = 12, face = "bold", angle = 90, vjust = 0.3, hjust = 1), 
        axis.text.y = element_text(colour = "black", face = "bold", size = 11), 
        legend.text = element_text(size = 10, face ="bold", colour ="black"), 
        legend.title = element_text(size = 12, face = "bold"), 
        panel.background = element_blank(), panel.border = element_rect(colour = "black", fill = NA, size = 1.2), 
        legend.position = "right") +  
  scale_fill_manual(values = colours)
#facet_grid(~Depth)

dotplot_bacteria





